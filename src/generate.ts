import {introspectSchema, isModelType, makeIntrospectionQuery} from "./makeIntrospectionQuery";
import {getTypeName, ModelGenerator} from "./generators/ModelGenerator";
import {
  IntrospectionEnumType,
  IntrospectionInputObjectType,
  IntrospectionListTypeRef,
  IntrospectionNonNullTypeRef,
  IntrospectionQuery,
  IntrospectionScalarType,
  IntrospectionType
} from "graphql/utilities";
import fs, {readFileSync, writeFileSync} from 'fs';
import {ScalarGenerator} from "./generators/ScalarGenerator";
import {InputObjectInterfaceGenerator} from "./generators/InputObjectInterfaceGenerator";
import {QueryGenerator} from "./generators/QueryGenerator";
import {RootStoreGenerator} from "./generators/RootStoreGenerator";
import { resolve } from 'path';
import {generateUseInstanceHooks} from "./generators/UseInstanceGenerator";
import {EnumGenerator} from "./generators/EnumGenerator";

type GenerateOpts = {
  url: string;
  outDir: string;
  include: string[] | null;
  exclude: string[] | null;
  writeReactUtilities: boolean;
  idFieldName: string;
}

export async function generate(opts: GenerateOpts) {
  const { url, outDir, include, exclude, writeReactUtilities, idFieldName } = opts;
  
  const introspection = await (async () => {
    if (url.startsWith('http')) {
      return await makeIntrospectionQuery(url);
    } else if (url.endsWith('.graphql')) {
      return await introspectSchema(url);
    } else if (url.endsWith('.json')) {
      const query = JSON.parse(readFileSync(url, 'utf-8')) as { data: IntrospectionQuery } | IntrospectionQuery;

      if ('data' in query) return query.data;
      if ('__schema' in query) return query;

      throw new Error(`Unable to get introspection from JSON file`);
    } else {
      throw new Error(`Unsupported source: ${url}`);
    }
  })();

  generateScalars(introspection);

  const models = generateModels(introspection);
  generateRootStore(models);

  generateInputObjectInterfaces(introspection);
  generateMutations(introspection);
  generateQueries(introspection);
  generateEnums(introspection);

  if (writeReactUtilities) {
    generateHooks();
  }

  function withDontEditWarning(code: string) {
    return `// This file was generated by mobx-depot. Do not edit this file directly.\n${code}`;
  }

  function generateHooks() {
    const useInstanceHooks = generateUseInstanceHooks();

    fs.writeFileSync(withOutDir(`depot/hooks.ts`), withDontEditWarning(useInstanceHooks));
  }

  function generateRootStore(models: ModelGenerator[]) {
    const rootStore = new RootStoreGenerator(models, { idFieldName });
  
    writeRootStoreToDisk(rootStore);
  }

  function generateEnums(query: IntrospectionQuery) {
    const enums = query.__schema.types.filter(type => type.kind === 'ENUM') as IntrospectionEnumType[];
    const generators = enums.map((enumType) => new EnumGenerator(enumType));

    writeEnumsToDisk(generators);
  }
  
  function generateQueries(query: IntrospectionQuery) {
    const queryType = query.__schema.types.find(type => type.name === 'Query');
    if (!queryType) {
      throw new Error('Expected queryType to be defined');
    }
  
    if (!('fields' in queryType)) {
      throw new Error('Expected queryType to have fields');
    }
  
    const generators = queryType.fields.map(field => new QueryGenerator(field, false));
  
    writeQueriesToDisk(generators);
  }
  
  function generateInputObjectInterfaces(query: IntrospectionQuery) {
    const inputObjectTypes = query.__schema.types
      .filter(type => type.kind === 'INPUT_OBJECT') as IntrospectionInputObjectType[];
  
    const generators = inputObjectTypes.map(type => new InputObjectInterfaceGenerator(type));
  
    writeInputObjectInterfacesToDisk(generators);
  }
  
  function generateMutations(query: IntrospectionQuery) {
    const mutationType = query.__schema.types.find(type => type.name === 'Mutation');
    if (!mutationType) return;
  
    if (!('fields' in mutationType)) {
      throw new Error('Expected mutationType to have fields');
    }
  
    const generators = mutationType.fields.map(field => new QueryGenerator(field, true));
  
    writeMutationsToDisk(generators);
  }
  
  function generateScalars(query: IntrospectionQuery) {
    const scalarTypes = query.__schema.types
      .filter(type => isScalarType(type) && !scalarIsPrimitive(type)) as IntrospectionScalarType[];

    if (scalarTypes.length === 0) return;
  
    const generators = scalarTypes.map(type => new ScalarGenerator(type));
  
    writeScalarsToDisk(generators);
  }
  
  function generateModels(query: IntrospectionQuery) {
    const modelGenerators = query.__schema.types
      .filter(isModelType)
      .filter(type => {
        if (include) {
          return include.includes(type.name);
        }

        if (exclude) {
          return !exclude.includes(type.name);
        }

        return true;
      })
      .map(type => new ModelGenerator(type, { idFieldName }));
  
    writeModelsToDisk(modelGenerators);
  
    return modelGenerators;
  }

  function withOutDir(path: string) {
    return resolve(outDir, path);
  }

  function writeEnumsToDisk(enumsGenerators: EnumGenerator[]) {
    if (!fs.existsSync(withOutDir('depot/enums'))) {
      fs.mkdirSync(withOutDir('depot/enums'), { recursive: true });
    }

    enumsGenerators.forEach(enumGenerator => {
      fs.writeFileSync(withOutDir(`depot/enums/${enumGenerator.fileName}`), withDontEditWarning(enumGenerator.code));
    });
  }

  function writeScalarsToDisk(scalars: ScalarGenerator[]) {
    if (!fs.existsSync(withOutDir('depot'))) {
      fs.mkdirSync(withOutDir('depot'), { recursive: true });
    }

    fs.writeFileSync(
      withOutDir(`depot/scalars.ts`),
      withDontEditWarning(scalars.map(scalar => scalar.code).join('\n\n'))
    );
  }
  
  function writeModelsToDisk(models: ModelGenerator[], force = false) {
    if (!fs.existsSync(withOutDir('depot/base/selectors'))) {
      fs.mkdirSync(withOutDir('depot/base/selectors'), { recursive: true });
    }
  
    models.forEach(model => {
      fs.writeFileSync(withOutDir(`depot/base/${model.baseModelFileName}`), withDontEditWarning(model.baseModelCode));
      fs.writeFileSync(withOutDir(`depot/base/selectors/${model.selectorGenerator.fileName}`), withDontEditWarning(model.selectorGenerator.code));

      const userEditablePath = withOutDir(`${model.userEditableModelFileName}`);
      if (!force && fs.existsSync(userEditablePath)) {
        return;
      }

      fs.writeFileSync(userEditablePath, model.userEditableModelCode)
    });
  }
  
  function writeInputObjectInterfacesToDisk(inputObjectInterfaces: InputObjectInterfaceGenerator[]) {
    if (!fs.existsSync(withOutDir('depot/inputs'))) {
      fs.mkdirSync(withOutDir('depot/inputs'), { recursive: true });
    }
  
    inputObjectInterfaces.forEach(inputObjectInterface => {
      fs.writeFileSync(withOutDir(`depot/inputs/${inputObjectInterface.fileName}`), withDontEditWarning(inputObjectInterface.code));
    });
  }
  
  function writeMutationsToDisk(mutations: QueryGenerator[]) {
    if (!fs.existsSync(withOutDir('depot/mutations'))) {
      fs.mkdirSync(withOutDir('depot/mutations'), { recursive: true });
    }
  
    mutations.forEach(mutation => {
      fs.writeFileSync(withOutDir(`depot/mutations/${mutation.fileName}`), withDontEditWarning(mutation.code));
    });
  }
  
  function writeQueriesToDisk(queries: QueryGenerator[]) {
    if (!fs.existsSync(withOutDir('depot/queries'))) {
      fs.mkdirSync(withOutDir('depot/queries'), { recursive: true });
    }
  
    queries.forEach(query => {
      fs.writeFileSync(withOutDir(`depot/queries/${query.fileName}`), withDontEditWarning(query.code));
    });
  }

  function writeRootStoreToDisk(rootStore: RootStoreGenerator) {
    if (!fs.existsSync(withOutDir('depot'))) {
      fs.mkdirSync(withOutDir('depot'), { recursive: true });
    }

    fs.writeFileSync(withOutDir(`depot/${rootStore.fileName}`), withDontEditWarning(rootStore.code));
  }
}

type Kind = IntrospectionType['kind'] | 'LIST' | 'NON_NULL';

/*
  There are a lot of functions spread out that answer questions about the introspection query.
  I'm wondering if we should implement some sort of Introspection class to encapsulate this logic.
*/

export function isScalarType(type: { kind: Kind, ofType?: { kind: Kind } }): type is { kind: 'SCALAR' } {
  if (type.kind == 'LIST' || type.kind == 'NON_NULL') {
    if (!type.ofType) throw new Error('Expected ofType to be defined');

    return isScalarType(type.ofType);
  }

  return type.kind === 'SCALAR';
}

export function scalarIsPrimitive(type: IntrospectionScalarType | IntrospectionNonNullTypeRef<IntrospectionScalarType> | IntrospectionListTypeRef<IntrospectionScalarType>) {
  let typeName = getTypeName(type, { normalizeName: true, stripArrayType: true });

  if (!typeName) {
    console.error(type);
    throw new Error('Expected typeName to be defined');
  }

  return ['string', 'number', 'boolean'].includes(typeName);
}
