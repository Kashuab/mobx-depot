import {introspectSchema, isModelType, makeIntrospectionQuery} from "./makeIntrospectionQuery";
import {getTypeName, ModelGenerator} from "./generators/ModelGenerator";
import {
  IntrospectionEnumType,
  IntrospectionInputObjectType,
  IntrospectionListTypeRef,
  IntrospectionNonNullTypeRef,
  IntrospectionQuery,
  IntrospectionScalarType,
  IntrospectionType
} from "graphql/utilities";
import fs, {readFileSync, writeFileSync} from 'fs';
import {ScalarGenerator} from "./generators/ScalarGenerator";
import {InputObjectInterfaceGenerator} from "./generators/InputObjectInterfaceGenerator";
import {QueryGenerator} from "./generators/QueryGenerator";
import {RootStoreGenerator} from "./generators/RootStoreGenerator";
import { resolve } from 'path';
import {generateUseInstanceHooks} from "./generators/UseInstanceGenerator";
import {EnumGenerator} from "./generators/EnumGenerator";
import dedent from "dedent";

type GenerateOpts = {
  url: string;
  outDir: string;
  include: string[] | null;
  exclude: string[] | null;
  writeReactUtilities: boolean;
  depotDirName: string;
  idFieldName: string;
}

export async function generate(opts: GenerateOpts) {
  const { url, outDir, include, exclude, writeReactUtilities, depotDirName, idFieldName } = opts;
  
  const introspection = await (async () => {
    if (url.startsWith('http')) {
      return await makeIntrospectionQuery(url);
    } else if (url.endsWith('.graphql')) {
      return await introspectSchema(url);
    } else if (url.endsWith('.json')) {
      const query = JSON.parse(readFileSync(url, 'utf-8')) as { data: IntrospectionQuery } | IntrospectionQuery;

      if ('data' in query) return query.data;
      if ('__schema' in query) return query;

      throw new Error(`Unable to get introspection from JSON file`);
    } else {
      throw new Error(`Unsupported source: ${url}`);
    }
  })();

  generateScalars(introspection);

  const models = generateModels(introspection);
  generateRootStore(models);

  const inputs = generateInputObjectInterfaces(introspection);
  const mutations = generateMutations(introspection);
  const queries = generateQueries(introspection);
  const enums = generateEnums(introspection);

  writeDepotIndex(models, queries, mutations, inputs, enums);

  if (writeReactUtilities) {
    generateHooks();
  }

  function withDontEditWarning(code: string) {
    return `// This file was generated by mobx-depot. Do not edit this file directly.\n${code}`;
  }

  function generateHooks() {
    const useInstanceHooks = generateUseInstanceHooks();

    fs.writeFileSync(withOutDir(`${depotDirName}/hooks.ts`), withDontEditWarning(useInstanceHooks));
  }

  function generateRootStore(models: ModelGenerator[]) {
    const rootStore = new RootStoreGenerator(models, { idFieldName });
  
    writeRootStoreToDisk(rootStore);
  }

  function generateEnums(query: IntrospectionQuery) {
    const enums = query.__schema.types.filter(type => {
      if (type.kind !== 'ENUM') return false;

      const blacklist = ['__TypeKind', '__DirectiveLocation'];
      if (blacklist.includes(type.name)) return false;

      return true;
    }) as IntrospectionEnumType[];
    const generators = enums.map((enumType) => new EnumGenerator(enumType));

    writeEnumsToDisk(generators);

    return generators;
  }
  
  function generateQueries(query: IntrospectionQuery) {
    const queryTypeName = query.__schema.queryType.name;
    const queryType = query.__schema.types.find(type => type.name === queryTypeName);
    if (!queryType) {
      throw new Error('Expected queryType to be defined');
    }
  
    if (!('fields' in queryType)) {
      throw new Error('Expected queryType to have fields');
    }
  
    const generators = queryType.fields.map(field => new QueryGenerator(field, false, writeReactUtilities));
  
    writeQueriesToDisk(generators);

    return generators;
  }
  
  function generateInputObjectInterfaces(query: IntrospectionQuery) {
    const inputObjectTypes = query.__schema.types
      .filter(type => type.kind === 'INPUT_OBJECT') as IntrospectionInputObjectType[];
  
    const generators = inputObjectTypes.map(type => new InputObjectInterfaceGenerator(type));
  
    writeInputObjectInterfacesToDisk(generators);

    return generators;
  }
  
  function generateMutations(query: IntrospectionQuery) {
    const mutationType = query.__schema.types.find(type => type.name === 'Mutation');
    if (!mutationType) return [];
  
    if (!('fields' in mutationType)) {
      throw new Error('Expected mutationType to have fields');
    }
  
    const generators = mutationType.fields.map(field => new QueryGenerator(field, true, writeReactUtilities));
  
    writeMutationsToDisk(generators);

    return generators;
  }
  
  function generateScalars(query: IntrospectionQuery) {
    const scalarTypes = query.__schema.types
      .filter(type => isScalarType(type) && !scalarIsPrimitive(type)) as IntrospectionScalarType[];

    if (scalarTypes.length === 0) return;
  
    const generators = scalarTypes.map(type => new ScalarGenerator(type));
  
    writeScalarsToDisk(generators);
  }
  
  function generateModels(query: IntrospectionQuery) {
    const modelGenerators = query.__schema.types
      .filter(isModelType)
      .filter(type => {
        if (include) {
          return include.includes(type.name);
        }

        if (exclude) {
          return !exclude.includes(type.name);
        }

        return true;
      })
      .map(type => new ModelGenerator(type, { idFieldName, depotDirName }));
  
    writeModelsToDisk(modelGenerators);
  
    return modelGenerators;
  }

  function withOutDir(path: string) {
    return resolve(outDir, path);
  }

  function writeEnumsToDisk(enumsGenerators: EnumGenerator[]) {
    if (!fs.existsSync(withOutDir(`${depotDirName}/enums`))) {
      fs.mkdirSync(withOutDir(`${depotDirName}/enums`), { recursive: true });
    }

    enumsGenerators.forEach(enumGenerator => {
      fs.writeFileSync(withOutDir(`${depotDirName}/enums/${enumGenerator.fileName}`), withDontEditWarning(enumGenerator.code));
    });
  }

  function writeScalarsToDisk(scalars: ScalarGenerator[]) {
    if (!fs.existsSync(withOutDir(depotDirName))) {
      fs.mkdirSync(withOutDir(depotDirName), { recursive: true });
    }

    fs.writeFileSync(
      withOutDir(`${depotDirName}/scalars.ts`),
      withDontEditWarning(scalars.map(scalar => scalar.code).join('\n\n'))
    );
  }
  
  function writeModelsToDisk(models: ModelGenerator[], force = false) {
    if (!fs.existsSync(withOutDir(`${depotDirName}/base/selector`))) {
      fs.mkdirSync(withOutDir(`${depotDirName}/base/selectors`), { recursive: true });
    }
  
    models.forEach(model => {
      fs.writeFileSync(withOutDir(`${depotDirName}/base/${model.baseModelFileName}`), withDontEditWarning(model.baseModelCode));
      fs.writeFileSync(withOutDir(`${depotDirName}/base/selectors/${model.selectorGenerator.fileName}`), withDontEditWarning(model.selectorGenerator.code));

      const userEditablePath = withOutDir(`${model.userEditableModelFileName}`);
      if (!force && fs.existsSync(userEditablePath)) {
        return;
      }

      fs.writeFileSync(userEditablePath, model.userEditableModelCode)
    });
  }
  
  function writeInputObjectInterfacesToDisk(inputObjectInterfaces: InputObjectInterfaceGenerator[]) {
    if (!fs.existsSync(withOutDir(`${depotDirName}/inputs`))) {
      fs.mkdirSync(withOutDir(`${depotDirName}/inputs`), { recursive: true });
    }
  
    inputObjectInterfaces.forEach(inputObjectInterface => {
      fs.writeFileSync(withOutDir(`${depotDirName}/inputs/${inputObjectInterface.fileName}`), withDontEditWarning(inputObjectInterface.code));
    });
  }
  
  function writeMutationsToDisk(mutations: QueryGenerator[]) {
    if (!fs.existsSync(withOutDir(`${depotDirName}/mutations`))) {
      fs.mkdirSync(withOutDir(`${depotDirName}/mutations`), { recursive: true });
    }
  
    mutations.forEach(mutation => {
      fs.writeFileSync(withOutDir(`${depotDirName}/mutations/${mutation.fileName}`), withDontEditWarning(mutation.code));
    });
  }
  
  function writeQueriesToDisk(queries: QueryGenerator[]) {
    if (!fs.existsSync(withOutDir(`${depotDirName}/queries`))) {
      fs.mkdirSync(withOutDir(`${depotDirName}/queries`), { recursive: true });
    }
  
    queries.forEach(query => {
      fs.writeFileSync(withOutDir(`${depotDirName}/queries/${query.fileName}`), withDontEditWarning(query.code));
    });
  }

  function writeRootStoreToDisk(rootStore: RootStoreGenerator) {
    if (!fs.existsSync(withOutDir(depotDirName))) {
      fs.mkdirSync(withOutDir(depotDirName), { recursive: true });
    }

    fs.writeFileSync(withOutDir(`${depotDirName}/${rootStore.fileName}`), withDontEditWarning(rootStore.code));
  }

  function writeDepotIndex(
    models: ModelGenerator[],
    queries: QueryGenerator[],
    mutations: QueryGenerator[],
    inputs: InputObjectInterfaceGenerator[],
    enums: EnumGenerator[]
  ) {
    const exports: string[] = [];

    models.forEach(model => {
      exports.push(`export * from './base/${model.baseModelClassName}';`)
    })

    queries.forEach(query => {
      exports.push(`export * from './queries/${query.className}';`);
    })

    mutations.forEach(mutation => {
      exports.push(`export * from './mutations/${mutation.className}';`);
    })

    inputs.forEach(input => {
      exports.push(`export * from './inputs/${input.interfaceName}';`);
    })

    enums.forEach(e => {
      exports.push(`export * from './enums/${e.name}';`);
    })

    exports.push(`export * from './rootStore';`);
    exports.push(`export * from './scalars';`);
    exports.push(`export * from './hooks';`);

    const index = withDontEditWarning(dedent`
      ${exports.join('\n')}
    `);

    writeFileSync(withOutDir(`${depotDirName}/index.ts`), index, 'utf-8');
  }
}

type Kind = IntrospectionType['kind'] | 'LIST' | 'NON_NULL';

/*
  There are a lot of functions spread out that answer questions about the introspection query.
  I'm wondering if we should implement some sort of Introspection class to encapsulate this logic.
*/

export function isScalarType(type: { kind: Kind, ofType?: { kind: Kind } }): type is { kind: 'SCALAR' } {
  if (type.kind == 'LIST' || type.kind == 'NON_NULL') {
    if (!type.ofType) throw new Error('Expected ofType to be defined');

    return isScalarType(type.ofType);
  }

  return type.kind === 'SCALAR';
}

export function scalarIsPrimitive(type: IntrospectionScalarType | IntrospectionNonNullTypeRef<IntrospectionScalarType> | IntrospectionListTypeRef<IntrospectionScalarType>) {
  let typeName = getTypeName(type, { normalizeName: true, stripArrayType: true });

  if (!typeName) {
    console.error(type);
    throw new Error('Expected typeName to be defined');
  }

  return ['string', 'number', 'boolean'].includes(typeName);
}
